{
  "version": 3,
  "sources": ["../../src/index.ts"],
  "sourcesContent": [
    "export interface FindResult<T> {\n\tstore: T\n\tparams: Record<string, any>\n}\n\nexport interface ParamNode<T> {\n\tname: string\n\tstore: T | null\n\tinert: Node<T> | null\n}\n\nexport interface Node<T> {\n\tpart: string\n\tstore: T | null\n\tinert: Record<number, Node<T>> | null\n\tparams: ParamNode<T> | null\n\twildcardStore: T | null\n}\n\nconst createNode = <T>(part: string, inert?: Node<T>[]): Node<T> => {\n\tconst inertMap: Record<number, Node<T>> | null = inert?.length ? {} : null\n\n\tif (inertMap)\n\t\tfor (const child of inert!) inertMap[child.part.charCodeAt(0)] = child\n\n\treturn {\n\t\tpart,\n\t\tstore: null,\n\t\tinert: inertMap,\n\t\tparams: null,\n\t\twildcardStore: null\n\t}\n}\n\nconst cloneNode = <T>(node: Node<T>, part: string) => ({\n\t...node,\n\tpart\n})\n\nconst createParamNode = <T>(name: string): ParamNode<T> => ({\n\tname,\n\tstore: null,\n\tinert: null\n})\n\ntype MaybeArray<T> = T | T[]\n\ntype ProcessParam = (value: string, key: string) => unknown\n\nexport interface Config {\n\t/**\n\t * lazily create nodes\n\t *\n\t * @default undefined\n\t * @since 0.3.0\n\t */\n\tlazy?: boolean\n\t/**\n\t * process dynamic parameter\n\t */\n\tonParam?: MaybeArray<ProcessParam>\n}\n\nexport class Memoirist<T> {\n\troot: Record<string, Node<T>> = {}\n\thistory: [string, string, T][] = []\n\tdeferred: [string, string, T][] = []\n\n\tconstructor(public config: Config = {}) {\n\t\tif (config.lazy)\n\t\t\t// @ts-expect-error\n\t\t\tthis.find = this.lazyFind\n\n\t\tif (config.onParam && !Array.isArray(config.onParam))\n\t\t\tthis.config.onParam = [\n\t\t\t\tthis.config.onParam as (param: string) => unknown\n\t\t\t]\n\t}\n\n\tprivate static regex = {\n\t\tstatic: /:.+?(?=\\/|$)/,\n\t\tparams: /:.+?(?=\\/|$)/g,\n\t\toptionalParams: /(\\/:\\w+\\?)/g\n\t}\n\n\tprivate lazyFind = (method: string, url: string) => {\n\t\tif (!this.config.lazy) return this.find\n\n\t\tthis.build()\n\n\t\treturn this.find(method, url)\n\t}\n\n\tbuild() {\n\t\tif (!this.config.lazy) return\n\n\t\tfor (const [method, path, store] of this.deferred)\n\t\t\tthis.add(method, path, store, { lazy: false, ignoreHistory: true })\n\n\t\tthis.deferred = []\n\n\t\tthis.find = (method: string, url: string): FindResult<T> | null => {\n\t\t\tconst root = this.root[method]\n\t\t\tif (!root) return null\n\n\t\t\treturn matchRoute(\n\t\t\t\turl,\n\t\t\t\turl.length,\n\t\t\t\troot,\n\t\t\t\t0,\n\t\t\t\tthis.config.onParam as ProcessParam[]\n\t\t\t)\n\t\t}\n\t}\n\n\tadd(\n\t\tmethod: string,\n\t\tpath: string,\n\t\tstore: T,\n\t\t{\n\t\t\tignoreError = false,\n\t\t\tignoreHistory = false,\n\t\t\tlazy = this.config.lazy\n\t\t}: {\n\t\t\tignoreError?: boolean\n\t\t\tignoreHistory?: boolean\n\t\t\tlazy?: boolean\n\t\t} = {}\n\t): FindResult<T>['store'] {\n\t\tif (lazy) {\n\t\t\t// @ts-expect-error\n\t\t\tthis.find = this.lazyFind\n\t\t\tthis.deferred.push([method, path, store])\n\n\t\t\treturn store\n\t\t}\n\n\t\tif (typeof path !== 'string')\n\t\t\tthrow new TypeError('Route path must be a string')\n\n\t\tif (path === '') path = '/'\n\t\telse if (path[0] !== '/') path = `/${path}`\n\n\t\tconst isWildcard = path[path.length - 1] === '*'\n\t\t// End with ? and is param\n\t\tconst optionalParams = path.match(Memoirist.regex.optionalParams)\n\n\t\tif (optionalParams) {\n\t\t\tconst originalPath = path.replaceAll('?', '')\n\t\t\tthis.add(method, originalPath, store, {\n\t\t\t\tignoreError,\n\t\t\t\tignoreHistory,\n\t\t\t\tlazy\n\t\t\t})\n\n\t\t\tfor (let i = 0; i < optionalParams.length; i++) {\n\t\t\t\tlet newPath = path.replace(optionalParams[i], '')\n\n\t\t\t\tthis.add(method, newPath, store, {\n\t\t\t\t\tignoreError: true,\n\t\t\t\t\tignoreHistory,\n\t\t\t\t\tlazy\n\t\t\t\t})\n\t\t\t}\n\n\t\t\treturn store\n\t\t}\n\n\t\tif (optionalParams) path = path.replaceAll('?', '')\n\n\t\tif (this.history.find(([m, p, s]) => m === method && p === path))\n\t\t\treturn store\n\n\t\tif (\n\t\t\tisWildcard ||\n\t\t\t(optionalParams && path.charCodeAt(path.length - 1) === 63)\n\t\t)\n\t\t\t// Slice off trailing '*'\n\t\t\tpath = path.slice(0, -1)\n\n\t\tif (!ignoreHistory) this.history.push([method, path, store])\n\n\t\tconst inertParts = path.split(Memoirist.regex.static)\n\t\tconst paramParts = path.match(Memoirist.regex.params) || []\n\n\t\tif (inertParts[inertParts.length - 1] === '') inertParts.pop()\n\n\t\tlet node: Node<T>\n\n\t\tif (!this.root[method]) node = this.root[method] = createNode<T>('/')\n\t\telse node = this.root[method]\n\n\t\tlet paramPartsIndex = 0\n\n\t\tfor (let i = 0; i < inertParts.length; ++i) {\n\t\t\tlet part = inertParts[i]\n\n\t\t\tif (i > 0) {\n\t\t\t\t// Set param on the node\n\t\t\t\tconst param = paramParts[paramPartsIndex++].slice(1)\n\n\t\t\t\tif (node.params === null) node.params = createParamNode(param)\n\t\t\t\telse if (node.params.name !== param) {\n\t\t\t\t\tif (ignoreError) return store\n\t\t\t\t\telse\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Cannot create route \"${path}\" with parameter \"${param}\" ` +\n\t\t\t\t\t\t\t\t'because a route already exists with a different parameter name ' +\n\t\t\t\t\t\t\t\t`(\"${node.params.name}\") in the same location`\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tconst params = node.params\n\n\t\t\t\tif (params.inert === null) {\n\t\t\t\t\tnode = params.inert = createNode(part)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tnode = params.inert\n\t\t\t}\n\n\t\t\tfor (let j = 0; ; ) {\n\t\t\t\tif (j === part.length) {\n\t\t\t\t\tif (j < node.part.length) {\n\t\t\t\t\t\t// Move the current node down\n\t\t\t\t\t\tconst childNode = cloneNode(node, node.part.slice(j))\n\t\t\t\t\t\tObject.assign(node, createNode(part, [childNode]))\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif (j === node.part.length) {\n\t\t\t\t\t// Add static child\n\t\t\t\t\tif (node.inert === null) node.inert = {}\n\n\t\t\t\t\tconst inert = node.inert[part.charCodeAt(j)]\n\n\t\t\t\t\tif (inert) {\n\t\t\t\t\t\t// Re-run loop with existing static node\n\t\t\t\t\t\tnode = inert\n\t\t\t\t\t\tpart = part.slice(j)\n\t\t\t\t\t\tj = 0\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create new node\n\t\t\t\t\tconst childNode = createNode<T>(part.slice(j))\n\t\t\t\t\tnode.inert[part.charCodeAt(j)] = childNode\n\t\t\t\t\tnode = childNode\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif (part[j] !== node.part[j]) {\n\t\t\t\t\t// Split the node\n\t\t\t\t\tconst existingChild = cloneNode(node, node.part.slice(j))\n\t\t\t\t\tconst newChild = createNode<T>(part.slice(j))\n\n\t\t\t\t\tObject.assign(\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tcreateNode(node.part.slice(0, j), [\n\t\t\t\t\t\t\texistingChild,\n\t\t\t\t\t\t\tnewChild\n\t\t\t\t\t\t])\n\t\t\t\t\t)\n\n\t\t\t\t\tnode = newChild\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\t++j\n\t\t\t}\n\t\t}\n\n\t\tif (paramPartsIndex < paramParts.length) {\n\t\t\t// The final part is a parameter\n\t\t\tconst param = paramParts[paramPartsIndex]\n\t\t\tconst name = param.slice(1)\n\n\t\t\tif (node.params === null) node.params = createParamNode(name)\n\t\t\telse if (node.params.name !== name) {\n\t\t\t\tif (ignoreError) return store\n\t\t\t\telse\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Cannot create route \"${path}\" with parameter \"${name}\" ` +\n\t\t\t\t\t\t\t'because a route already exists with a different parameter name ' +\n\t\t\t\t\t\t\t`(\"${node.params.name}\") in the same location`\n\t\t\t\t\t)\n\t\t\t}\n\n\t\t\tif (node.params.store === null) node.params.store = store\n\n\t\t\treturn node.params.store!\n\t\t}\n\n\t\tif (isWildcard) {\n\t\t\t// The final part is a wildcard\n\t\t\tif (node.wildcardStore === null) node.wildcardStore = store\n\n\t\t\treturn node.wildcardStore!\n\t\t}\n\n\t\t// The final part is static\n\t\tif (node.store === null) node.store = store\n\n\t\treturn node.store!\n\t}\n\n\tfind(method: string, url: string): FindResult<T> | null {\n\t\tconst root = this.root[method]\n\t\tif (!root) return null\n\n\t\treturn matchRoute(\n\t\t\turl,\n\t\t\turl.length,\n\t\t\troot,\n\t\t\t0,\n\t\t\tthis.config.onParam as ProcessParam[]\n\t\t)\n\t}\n}\n\nconst matchRoute = <T>(\n\turl: string,\n\turlLength: number,\n\tnode: Node<T>,\n\tstartIndex: number,\n\tonParam?: ProcessParam[]\n): FindResult<T> | null => {\n\tconst part = node.part\n\tconst length = part.length\n\tconst endIndex = startIndex + length\n\n\t// Only check the pathPart if its length is > 1 since the parent has\n\t// already checked that the url matches the first character\n\tif (length > 1) {\n\t\tif (endIndex > urlLength) return null\n\n\t\t// Using a loop is faster for short strings\n\t\tif (length < 15) {\n\t\t\tfor (let i = 1, j = startIndex + 1; i < length; ++i, ++j)\n\t\t\t\tif (part.charCodeAt(i) !== url.charCodeAt(j)) return null\n\t\t} else if (url.slice(startIndex, endIndex) !== part) return null\n\t}\n\n\t// Reached the end of the URL\n\tif (endIndex === urlLength) {\n\t\tif (node.store !== null)\n\t\t\treturn {\n\t\t\t\tstore: node.store,\n\t\t\t\tparams: {}\n\t\t\t}\n\n\t\tif (node.wildcardStore !== null)\n\t\t\treturn {\n\t\t\t\tstore: node.wildcardStore,\n\t\t\t\tparams: { '*': '' }\n\t\t\t}\n\n\t\treturn null\n\t}\n\n\t// Check for a static leaf\n\tif (node.inert !== null) {\n\t\tconst inert = node.inert[url.charCodeAt(endIndex)]\n\n\t\tif (inert !== undefined) {\n\t\t\tconst route = matchRoute(url, urlLength, inert, endIndex, onParam)\n\n\t\t\tif (route !== null) return route\n\t\t}\n\t}\n\n\t// Check for dynamic leaf\n\tif (node.params !== null) {\n\t\tconst { store, name, inert } = node.params\n\t\tconst slashIndex = url.indexOf('/', endIndex)\n\n\t\tif (slashIndex !== endIndex) {\n\t\t\t// Params cannot be empty\n\t\t\tif (slashIndex === -1 || slashIndex >= urlLength) {\n\t\t\t\tif (store !== null) {\n\t\t\t\t\t// This is much faster than using a computed property\n\t\t\t\t\tconst params: Record<string, string> = {}\n\t\t\t\t\tparams[name] = url.substring(endIndex, urlLength)\n\t\t\t\t\tif (onParam)\n\t\t\t\t\t\tfor (let i = 0; i < onParam.length; i++) {\n\t\t\t\t\t\t\tlet temp = onParam[i](params[name], name)\n\t\t\t\t\t\t\tif (temp !== undefined) params[name] = temp as any\n\t\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstore,\n\t\t\t\t\t\tparams\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (inert !== null) {\n\t\t\t\tconst route = matchRoute(\n\t\t\t\t\turl,\n\t\t\t\t\turlLength,\n\t\t\t\t\tinert,\n\t\t\t\t\tslashIndex,\n\t\t\t\t\tonParam\n\t\t\t\t)\n\n\t\t\t\tif (route !== null) {\n\t\t\t\t\troute.params[name] = url.substring(endIndex, slashIndex)\n\t\t\t\t\tif (onParam)\n\t\t\t\t\t\tfor (let i = 0; i < onParam.length; i++) {\n\t\t\t\t\t\t\tlet temp = onParam[i](route.params[name], name)\n\t\t\t\t\t\t\tif (temp !== undefined)\n\t\t\t\t\t\t\t\troute.params[name] = temp as any\n\t\t\t\t\t\t}\n\n\t\t\t\t\treturn route\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check for wildcard leaf\n\tif (node.wildcardStore !== null)\n\t\treturn {\n\t\t\tstore: node.wildcardStore,\n\t\t\tparams: {\n\t\t\t\t'*': url.substring(endIndex, urlLength)\n\t\t\t}\n\t\t}\n\n\treturn null\n}\n\nexport default Memoirist\n"
  ],
  "mappings": "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",
  "debugId": "7CB9F845001CCC1464756E2164756E21",
  "names": []
}